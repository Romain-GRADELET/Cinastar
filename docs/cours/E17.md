# E17

## challenge Event : MaintenanceSubcriber

[Listener vs subscriber](https://symfony.com/doc/5.4/event_dispatcher.html#listeners-or-subscribers)

Subscriber se suffit Ã  lui mÃªme, tout en un

Listener doit Ãªtre configurÃ© dans services.yaml

### notre subscriber

Objectif : afficher un message d'alerte sur toutes les pages

Comment mettre du html sur toutes les pages sans passer par twig ?

Pour afficher quelque chose dans toutes les pages, on peut d'inspirer de ce qui [est fait pour 'injecter' la toolbar de profiler.](https://github.com/symfony/web-profiler-bundle/blob/c779222d5a87b7d947e56ac09b02adb34cf8b610/EventListener/WebDebugToolbarListener.php#L137)

On remarque de suite que c'est un [KernelEvent](https://github.com/symfony/web-profiler-bundle/blob/c779222d5a87b7d947e56ac09b02adb34cf8b610/EventListener/WebDebugToolbarListener.php#L162)

Chouette, on sait faire les subscriber. ğŸ˜

```bash
bin/console make:subscriber
```

On choisit `Kernel.response` comme on l'a vu dans le code de la barre de profiler.

Mais ensuite ğŸ¤” ?
le code de la barre de profiler n'est pas trÃ¨s explicite ğŸ˜…

RÃ©flÃ©chissons, on est sur l'event `response`, on a donc accÃ¨s Ã  la rÃ©ponse HTML juste avant qu'elle soit envoyÃ©e.
Si on modifiait le contenu du HTML ? un peu comme en JS on manipule le DOM.

Pour Ã§a on veut obtenir quoi ?
une balise `<div class="alert alert-danger m-3">Maintenance prÃ©vue jeudi 25 mai Ã  17h00</div>` mais oÃ¹ ?

C'est subjectif, mais choissisons un endroit visible ğŸ¤“, disons juste aprÃ¨s la `<nav>`

On va donc rechercher la `nav` dans le contenu de la page, que l'on obtient avec le `ResponseEvent` passÃ© en paramÃ¨tre.

On y insÃ¨re notre message juste aprÃ¨s.

```php
// la rÃ©ponse HTTP
$response = $event->getResponse();
// le contenu HTML
$content = $response->getContent();
// On ajoute le code de la banniÃ¨re aprÃ¨s la balise nav du contenu HTML
$newHtml = str_replace(
    // Qu'est-ce qu'on cherche ?
    '</nav>',
    // Par quoi on remplace ?
    '</nav><div class="alert alert-danger m-3">Maintenance prÃ©vue jeudi 25 mai Ã  17h00</div>',
    // Dans quelle chaine ?
    $content
);
// On assigne le nouveau contenu Ã  la rÃ©ponse
$response->setContent($newHtml);

// /!\ Nul besoin de retourner quoique ce soit ou d'appeler une mÃ©thode spÃ©cifique
// l'objet $reponse a Ã©tÃ© manipulÃ© directement et sera envoyÃ© par le Kernel
```

[doc](https://symfony.com/doc/5.4/event_dispatcher.html#creating-an-event-subscriber)

### paramÃ©trage d'un service/subscriber

#### 1 Ã¨re Ã©tape : modifier le code pour gÃ©rer la conditionnalitÃ©

on crÃ©er une propriÃ©tÃ©, que l'on change selon nos besoins

```php
// private $maintenanceActive = true;

if (!$this->maintenanceActive){
    // la maintenance est dÃ©sactivÃ©
    // on s'arrÃªte lÃ 
    return;
}
```

Ã§a fonctionne, mais on doit changer le code pour activer/dÃ©sactiver la fonctionnalitÃ©

#### 2 Ã¨me Ã©tape : rendre le service/subscriber paramÃ©trable dans le fichier services.yaml

on rend notre service paramÃ©trable en ajoutant un constructeur avec des arguments

```php
/**
 * @param bool $argMaintenanceActive paramÃ©trable dans le fichier services.yaml
 */
public function __construct($argMaintenanceActive)
{
    $this->maintenanceActive = $argMaintenanceActive;
}
```

dans le fichier services.yaml, on prÃ©cise la valeur des arguments

```yaml
    # Pour paramÃ©trer un service je dois fournir le FQCN du service
    App\EventSubscriber\MaintenanceSubscriber:
        # on explique que notre service a des arguments
        arguments:
            # on prÃ©cise alors le nom de l'argument
            # ainsi que la valeur qu'il va avoir
            $argMaintenanceActive: true
```

#### 3 Ã¨me Ã©tape : le faire depuis le fichier .env

l'objectif est de se servir du fichier `.env` comme ceci:

```ini
###> MaintenanceSubscriber ###
MAINTENANCE_ACTIVE=true
###< MaintenanceSubscriber ###
```

pour cela on modifie le fichier `services.yaml` en prÃ©cisant le nom du paramÃ¨tre Ã  lire dans le fichier `.env`

**ATTENTION** au type de donnÃ©e car on lisant le fichier `.env` tout est chaine de caractÃ¨re.
Par exemple si on veux un boolÃ©en, la chaine 'false' ne sera pas comprise comme la valeur `false`

[doc](https://symfony.com/doc/current/configuration/env_var_processors.html#built-in-environment-variable-processors)

```yaml
    # Pour paramÃ©trer un service je dois fournir le FQCN du service
    App\EventSubscriber\MaintenanceSubscriber:
        # on explique que notre service a des arguments
        arguments:
            # on prÃ©cise alors le nom de l'argument
            # ainsi que la valeur qu'il va avoir
            $argMaintenanceActive: '%env(bool:MAINTENANCE_ACTIVE)%'
```

## API

Happy ?
Pomme d'API ?

[exemple de sÃ©paration](https://www.githubstatus.com/)

[api.gouv.fr](https://api.gouv.fr/rechercher-api)

[public api list](https://github.com/public-apis/public-apis)

[omdbapi](https://www.omdbapi.com/)

[exemple agregation API](https://www.data.gouv.fr/fr/reuses/covid-api-graphql/)

[exemple utilisation API avec Symfony](https://yoandev.co/consommer-une-api-avec-httpclient-et-symfony-5-les-chiffres-du-covid/)

la rÃ¨gle absolu : **API = NO HTML**

### API : GET

premier exemple : fournir la liste des genres

On crÃ©er une nouvelle route : `/api/genres`
Pour cela il nous faut un controller : `Api\GenreController`

Pour notre controller, on ne veux plus de twig, pas de rendu HTML

```bash
bin/console make:controller --no-template
```

On remarque que le retour du controller Ã  changÃ© de `render()` Ã  `json()`

Et c'est tout, on sait faire une API maintenant ğŸ‰

C'est trop simple pour Ãªtre vrai ...

Si je renvoit le rÃ©sultat d'un findAll() j'obtiens :

```js
[
  {},{},{},{},{},{},{},{},{},{},{},{},{},{},{},{}
]
```

le serializer 'de base' ne sait pas aller chercher les propriÃ©tÃ©s privÃ©es
on a donc des objets vides, mais on a le bon nombre d'objet

On installe donc le [serializer de symfony](https://symfony.com/doc/5.4/components/serializer.html)

```bash
composer require symfony/serializer
```

Maintenant la mÃ©thode `json()` est capable de lire:

* les propriÃ©tÃ©s privÃ©es
* les relations

La lecture des relations nous pose problÃ¨me car toutes nos entitÃ©s sont liÃ©s entre elles.
On va avoir l'erreur `A circular reference has been detected when serializing`

On va utiliser les groupes de sÃ©rialisation pour indiquer les propriÃ©tÃ©s que l'on veux rÃ©cupÃ©rer via la serialisation

#### @Groups

[doc](https://symfony.com/doc/5.4/components/serializer.html#attributes-groups)

sur nos entitÃ©s, on va dire quels sont les propriÃ©tÃ©s que l'on veux serializer

```php
use Symfony\Component\Serializer\Annotation\Groups;
/**
 * @Groups({"group1", "group2"}) // plusieurs groupes sur une ligne
 * @Groups({"group4"}) // un seul groupe
 * @Groups("group3") // un seul groupe
 * @Groups("group5") // un seul groupe
 * @Groups("group6") // un seul groupe
 */
public $anotherProperty;
```

il faut Ãªtre rigoureux sur le nommage des groupes, car vu le nombre de mÃ©thode API que l'on va developper ...

Ensuite il faut fournir le nom du/des groupes au serializer.
Pour cela on utilise le paramÃ¨tre `context` de la mÃ©thode `json()`

```php
return $this->json(
        // les donnÃ©es
        $allGenres, 
        // le code de retour : 200 par dÃ©faut
        200,
        // les entÃªtes HTTP, on ne s'en sert pas : []
        [],
        // le contexte de serialisation : les groupes
        [
            "groups" => 
            [
                "genre_browse", "group5"
            ]
        ]
    );
```

On en profite pour mettre nos groupes sur les relations, et aussi sur les entitÃ©s liÃ©s

```php
class Genre {
    /*
    * @Groups({"genre_browse"})
    */
    private $movies;
}
class Movie
{
    /**
     * @ORM\Column(type="string", length=255)
     * 
     * @Groups({"genre_browse"})
     */
    private $title;
}
```

**ATTENTION** Ã  ne pas refaire de boucle infinie en mettant l'annotation sur la relation inverse

**ATTENTION** les dev front vont vous demandez toujours plus.
cÃ d : je veux les genres avec leur films, ainsi que leur types, et le nombre de season

Il faut leur expliquer qu'il ya d'autre routes pour rÃ©cupÃ©rer des infos plus complÃ¨tes.

ex :

* Genres (all prop) > Movies (id+title)
* Movies (all prop) > Genres (id+name)

Il faut leur expliquer qu'a chaque "liaison" c'est une requet de plus, et si ils/elles veulent leur donnÃ©es rapidement, il faut que l'on limite le nombre de requetes

### Le dev Front

quand le dev front appelle une de nos route (endpoint) il reÃ§oit du JSON.
avec ce JSON, il va faire `json.Parse()` si il le fait manuellement (comme en S07 avec `fetch`), si il utilise un package pour les requetes API (`Axios`) se sera fait automatiquement pour lui.

Dans tout les cas il manipule un objet.

Il faut communiquer avec le dev front pour qu'il sache la structure des objets que vous allez lui envoyer.
Il faut lui fournir un exemple de JSON.
Ensuite il a aussi des outils pour simuler une API qui vont lui envoyer du JSON.

Je vous propose de faire :

* faire votre MCD (dev back)
* faire les wireframes (dev front)
* Ã©crire les besoins de donnÃ©e pour les wireframes
  * faire des JSON d'exemple
  * ex : `/api/movies/<ID>` => `{"id":1234, "title":"le zoli titre"}`
  * le nom des propriÃ©tÃ©s n'est pas hyper important

Qunad le dev back a fini un endpoint, on peut aller dire au front de changer son endpoint `/test/api/movies/201` => `http://<student.vpn.lan>/api/movies/201`

### REST naming ressources

### API : POST/PUT/PATCH

### API : DELETE

## Annexes

### Extension VSCode ThunderClient

```text
NomÂ : Thunder Client
IDÂ : rangav.vscode-thunder-client
DescriptionÂ : Lightweight Rest API Client for VS Code
VersionÂ : 2.7.0
Serveur de publicationÂ : Ranga Vadhineni
Lien de la Place de marchÃ© pour VSÂ : https://marketplace.visualstudio.com/items?itemName=rangav.vscode-thunder-client
```
