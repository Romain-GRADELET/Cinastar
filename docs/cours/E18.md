# E18

## REST naming ressources

[doc](https://restfulapi.net/resource-naming/)

### nom des Endpoints (routes) : Collections et Singleton

toutes nos routes parlent de ressources, c'est √† dire nos entit√©s dans O'Flix

il faut les mettre au pluriels, car √ßa induit le fait de r√©cup√©rer une collection d'objets

On ajoute l'ID pour ne r√©cup√©rer qu'une seule ressource : singleton

```text
GET /api/movies
GET /api/movies/221
```

On a la possibilit√© de faire des sous-ressources et des sous-singleton

```text
GET /api/movies/221/seasons
GET /api/movies/221/seasons/489
```

ne pas utiliser le `/` seul √† la fin
ne pas utiliser le `_` mais utiliser le `-` dans nos URL

### utilisation des m√©thodes plut√¥t que de verbes dans l'URL

Les m√©thods prennent une place essentielle dans notre endpoint

```text
GET  /api/movies : r√©cup√©rer toutes les films
POST /api/movies : cr√©er un nouveau film
```

## cot√© code : BREAD vs CRUD

CRUD : Create Read Update Delete
Ce sont les nommages pour les actions de BDD
Cela ne correspond pas √† notre vision d'API REST

BREAD : Browse Read Edit Add Delete
Ce sont les nommages pour les m√©thodes de controller (API)
Cela correspond mieux √† notre vision d'API REST
Ce n'est pas une obligation, mais JB trouve √ßa pas mal.

## API : 404

On a pas le droit de faire du HTML, donc pas le droit √† lancer des exceptions

Il faut donc renvoyer "manuellement" un code de status 404

```php
if ($movie === null){
    // ! on est dans une API donc pas de HTML
    // throw $this->createNotFoundException();
    return $this->json(
        // on pense UX : on fournit un message
        [
            "message" => "Ce film n'existe pas"
        ],
        // le code de status : 404
        Response::HTTP_NOT_FOUND
        // on a pas besoin de preciser les autres arguments
    );
}
```

## API : POST/PUT/PATCH

### POST et deserialize

Quand on est en mode "API", si on permet la cr√©ation avec la route `POST`, on doit s'attendre √† recevoir du JSON.

Simple en PHP, on `deserialize` le json que l'on re√ßoit et üí• on a un objet PHP.

On injecte la requ√®te HTTP dans notre fonction pour en r√©cup√©rer le contenu

```php
use Symfony\Component\HttpFoundation\Request;

public function createItem(Request $request)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
```

Comme pr√©vu on `deserialize`, c'est √† dire que l'on transforme le JSON en Objet en pr√©cisant l'entit√© que l'on veux.

On n'oublie pas d'injecter le Serializer de Symfony

```php
use Symfony\Component\Serializer\SerializerInterface;

public function createItem(Request $request, SerializerInterface $serializer)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
```

üéâ trop facile, on donnes √ßa √† Doctrine pour qu'il le mettes en BDD et c'est bon üí™

```php
public function createItem(Request $request, SerializerInterface $serializer, MovieRepository $movieRepository)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // On sauvegarde l'entit√©
    $movieRepository->add($movie, true);
```

#### validation des donn√©es

üòÖ `SQLSTATE[xxxx] xxxx cannot be null`

Comment √ßa MySQL n'est pas content ? üëø

Ben oui, il manque des donn√©es, on va demander √† Symfony de nous valider tout √ßa üí™ et surtout de nous dire ce qui coince.
Comme √ßa on pr√©vient notre utilisateur en front et on lui d√©crit les probl√®mes pour qu'il s'adapte et qu'il nous envoie les bonnes donn√©es.

```php
use Symfony\Component\Validator\Validator\ValidatorInterface;

public function createItem(Request $request, SerializerInterface $serializer, EntityManagerInterface $doctrine, ValidatorInterface $validator)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // Valider l'entit√©
    // @link : https://symfony.com/doc/current/validation.html#using-the-validator-service
    $errors = $validator->validate($movie);

    // Y'a-t-il des erreurs ?
    if (count($errors) > 0) {
        // TODO Retourner des erreurs de validation propres
        return $this->json($errors, Response::HTTP_UNPROCESSABLE_ENTITY);
    }
    // On sauvegarde l'entit√©
    $doctrine->persist($movie);
    $doctrine->flush();
```

### Gestion des erreurs de format de json

erreur : `Syntax Error`

si le deserialiseur lance une exception, c'est que le json n'est pas valide.
On va alors attraper l'erreur et renvoyer un code d'erreur 400 ou 422

```php
try { // on tente de d√©s√©rialiser
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
} catch (Exception $exception){
    // Si on n'y arrive pas, on passe ici
    return $this->json("JSON Invalide", Response::HTTP_BAD_REQUEST);
}
```


### PUT/PATCH : modification

De quoi on a besoin ?

* d'un ID => on le r√©cup√®re de la route
* des nouvelles valeurs => on les r√©cup√®re dans le contenu

la seule diff√©rence avec la cr√©ation c'est le contexte de deserialisation o√π l'on pr√©cise que l'on veux mettre √† jour un objet existant

```php
$jsonContent = $request->getContent();
$genre = $genreRepository->find($id);
$serializerInterface->deserialize(
    // les donn√©es
    $jsonContent,
    // le type d'objet
    Genre::class,
    // le format de donn√©e
    'json',
    // ? https://symfony.com/doc/5.4/components/serializer.html#deserializing-in-an-existing-object
    // en contexte on pr√©cise que l'on veux POPULATE / PEUPLER un objet existant
    [AbstractNormalizer::OBJECT_TO_POPULATE => $genre]
);
```

#### PUT vs PATCH

[PUT](https://restfulapi.net/http-methods/#put) : modifier l'existant enti√®rement
[PATCH](https://restfulapi.net/http-methods/#patch) : modifier partiellement

il n'y a pas de consensus sur lequel utiliser.

JB propose de mettre les deux pour ne facher personne.
Mais on peux aussi documenter notre API et n'accepter qu'un des deux.

## API : DELETE

on a juste besoin d'un ID, que l'on obtient par la route, et ensuite un `remove()` depuis le repository fera l'affaire.

## API : validation des donn√©es

## API : la s√©curit√©

