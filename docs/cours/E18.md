# E18

## REST naming ressources

[doc](https://restfulapi.net/resource-naming/)

### nom des Endpoints (routes) : Collections et Singleton

toutes nos routes parlent de ressources, c'est à dire nos entités dans O'Flix

il faut les mettre au pluriels, car ça induit le fait de récupérer une collection d'objets

On ajoute l'ID pour ne récupérer qu'une seule ressource : singleton

```text
GET /api/movies
GET /api/movies/221
```

On a la possibilité de faire des sous-ressources et des sous-singleton

```text
GET /api/movies/221/seasons
GET /api/movies/221/seasons/489
```

ne pas utiliser le `/` seul à la fin
ne pas utiliser le `_` mais utiliser le `-` dans nos URL

### utilisation des méthodes plutôt que de verbes dans l'URL

Les méthods prennent une place essentielle dans notre endpoint

```text
GET  /api/movies : récupérer toutes les films
POST /api/movies : créer un nouveau film
```

## coté code : BREAD vs CRUD

CRUD : Create Read Update Delete
Ce sont les nommages pour les actions de BDD
Cela ne correspond pas à notre vision d'API REST

BREAD : Browse Read Edit Add Delete
Ce sont les nommages pour les méthodes de controller (API)
Cela correspond mieux à notre vision d'API REST
Ce n'est pas une obligation, mais JB trouve ça pas mal.

## API : 404

On a pas le droit de faire du HTML, donc pas le droit à lancer des exceptions

Il faut donc renvoyer "manuellement" un code de status 404

```php
if ($movie === null){
    // ! on est dans une API donc pas de HTML
    // throw $this->createNotFoundException();
    return $this->json(
        // on pense UX : on fournit un message
        [
            "message" => "Ce film n'existe pas"
        ],
        // le code de status : 404
        Response::HTTP_NOT_FOUND
        // on a pas besoin de preciser les autres arguments
    );
}
```

## API : POST/PUT/PATCH

### POST : création

la création se fait en 3 étapes :

* on récupère le JSON de notre requete
* on deserialise pour obtenir un objet
* on persist et flush cet objet

```php
$jsonContent = $request->getContent();
/** @var Genre $newGenre */
$newGenre = $serializerInterface->deserialize(
    // les données à transformer/deserialiser
    $jsonContent,
    // vers quel type d'objet je veux deserialiser
    Genre::class,
    // quel est le format du contenu : json
    'json'
);

$genreRepository->add($newGenre, true);

return $this->json(
    // on fournit l'objet créer
    $newGenre,
    // le code 201 pour la création
    Response::HTTP_CREATED,
    // toujour pas d'entête
    [],
    // on oublie pas le contexte car on serialise un objet
    [
        "groups" =>
        [
            // j'utilise un groupe déjà existant
            "genre_read",
            "movie_browse"
        ]
    ]
);
```

### PUT/PATCH : modification

De quoi on a besoin ?

* d'un ID => on le récupère de la route
* des nouvelles valeurs => on les récupère dans le contenu

la seule différence avec la création c'est le contexte de deserialisation où l'on précise que l'on veux mettre à jour un objet existant

```php
$jsonContent = $request->getContent();
$genre = $genreRepository->find($id);
$serializerInterface->deserialize(
    // les données
    $jsonContent,
    // le type d'objet
    Genre::class,
    // le format de donnée
    'json',
    // ? https://symfony.com/doc/5.4/components/serializer.html#deserializing-in-an-existing-object
    // en contexte on précise que l'on veux POPULATE / PEUPLER un objet existant
    [AbstractNormalizer::OBJECT_TO_POPULATE => $genre]
);
```


#### PUT vs PATCH

[PUT](https://restfulapi.net/http-methods/#put) : modifier l'existant entièrement
[PATCH](https://restfulapi.net/http-methods/#patch) : modifier partiellement

il n'y a pas de consensus sur lequel utiliser.

JB propose de mettre les deux pour ne facher personne.
Mais on peux aussi documenter notre API et n'accepter qu'un des deux.

## API : DELETE

on a juste besoin d'un ID, que l'on obtie