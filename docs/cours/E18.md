# E18

## REST naming ressources

[doc](https://restfulapi.net/resource-naming/)

### nom des Endpoints (routes) : Collections et Singleton

toutes nos routes parlent de ressources, c'est √† dire nos entit√©s dans O'Flix

il faut les mettre au pluriels, car √ßa induit le fait de r√©cup√©rer une collection d'objets

On ajoute l'ID pour ne r√©cup√©rer qu'une seule ressource : singleton

```text
GET /api/movies
GET /api/movies/221
```

On a la possibilit√© de faire des sous-ressources et des sous-singleton

```text
GET /api/movies/221/seasons
GET /api/movies/221/seasons/489
```

ne pas utiliser le `/` seul √† la fin
ne pas utiliser le `_` mais utiliser le `-` dans nos URL

### utilisation des m√©thodes plut√¥t que de verbes dans l'URL

Les m√©thods prennent une place essentielle dans notre endpoint

```text
GET  /api/movies : r√©cup√©rer toutes les films
POST /api/movies : cr√©er un nouveau film
```

## cot√© code : BREAD vs CRUD

CRUD : Create Read Update Delete
Ce sont les nommages pour les actions de BDD
Cela ne correspond pas √† notre vision d'API REST

BREAD : Browse Read Edit Add Delete
Ce sont les nommages pour les m√©thodes de controller (API)
Cela correspond mieux √† notre vision d'API REST
Ce n'est pas une obligation, mais JB trouve √ßa pas mal.

## API : 404

On a pas le droit de faire du HTML, donc pas le droit √† lancer des exceptions

Il faut donc renvoyer "manuellement" un code de status 404

```php
if ($movie === null){
    // ! on est dans une API donc pas de HTML
    // throw $this->createNotFoundException();
    return $this->json(
        // on pense UX : on fournit un message
        [
            "message" => "Ce film n'existe pas"
        ],
        // le code de status : 404
        Response::HTTP_NOT_FOUND
        // on a pas besoin de preciser les autres arguments
    );
}
```

## API : POST/PUT/PATCH

### POST et deserialize

Quand on est en mode "API", si on permet la cr√©ation avec la route `POST`, on doit s'attendre √† recevoir du JSON.

Simple en PHP, on `deserialize` le json que l'on re√ßoit et üí• on a un objet PHP.

On injecte la requ√®te HTTP dans notre fonction pour en r√©cup√©rer le contenu

```php
use Symfony\Component\HttpFoundation\Request;

public function createItem(Request $request)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
```

Comme pr√©vu on `deserialize`, c'est √† dire que l'on transforme le JSON en Objet en pr√©cisant l'entit√© que l'on veux.

On n'oublie pas d'injecter le Serializer de Symfony

```php
use Symfony\Component\Serializer\SerializerInterface;

public function createItem(Request $request, SerializerInterface $serializer)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
```

üéâ trop facile, on donnes √ßa √† Doctrine pour qu'il le mettes en BDD et c'est bon üí™

```php
public function createItem(Request $request, SerializerInterface $serializer, MovieRepository $movieRepository)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // On sauvegarde l'entit√©
    $movieRepository->add($movie, true);
```

#### validation des donn√©es

üòÖ `SQLSTATE[xxxx] xxxx cannot be null`

Comment √ßa MySQL n'est pas content ? üëø

Ben oui, il manque des donn√©es, on va demander √† Symfony de nous valider tout √ßa üí™ et surtout de nous dire ce qui coince.
Comme √ßa on pr√©vient notre utilisateur en front et on lui d√©crit les probl√®mes pour qu'il s'adapte et qu'il nous envoie les bonnes donn√©es.

```php
use Symfony\Component\Validator\Validator\ValidatorInterface;

public function createItem(Request $request, SerializerInterface $serializer, EntityManagerInterface $doctrine, ValidatorInterface $validator)
{
    // R√©cup√©rer le contenu JSON
    $jsonContent = $request->getContent();
    // D√©s√©rialiser (convertir) le JSON en entit√© Doctrine Movie
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
    // Valider l'entit√©
    // @link : https://symfony.com/doc/current/validation.html#using-the-validator-service
    $errors = $validator->validate($movie);

    // Y'a-t-il des erreurs ?
    if (count($errors) > 0) {
        // TODO Retourner des erreurs de validation propres
        return $this->json($errors, Response::HTTP_UNPROCESSABLE_ENTITY);
    }
    // On sauvegarde l'entit√©
    $doctrine->persist($movie);
    $doctrine->flush();
```

### Gestion des erreurs de format de json

erreur : `Syntax Error`

si le deserialiseur lance une exception, c'est que le json n'est pas valide.
On va alors attraper l'erreur et renvoyer un code d'erreur 400 ou 422

```php
try { // on tente de d√©s√©rialiser
    $movie = $serializer->deserialize($jsonContent, Movie::class, 'json');
} catch (Exception $exception){
    // Si on n'y arrive pas, on passe ici
    return $this->json("JSON Invalide", Response::HTTP_BAD_REQUEST);
}
```

### DoctrineDenormalizer

Quand on cr√©er un film, on veux l'associer √† son type.

Pour cela le front nous fournit dans la propri√©t√© "type" un ID

Le serialiser n'arrive pas √† rechercher l'entit√© en BDD.
On cr√©er donc une classe de d√©normalisation pour nous m√™me faire la recherche dans la BDD.

A la condition que l'objet recherch√© est une entit√© ET que l'on me fournisse un ID.

ex : Movie -> Type

```js
{
    "title" : "Mon Film",
    "type" : 13
}
```

La classe en question : `DoctrineDenormalizer` peut √™tre copi√© d'un projet √† l'autre.
Et pouf √ßa marche.

**ATTENTION** cela marche si l'entit√© li√© n'est pas une collection (plusieurs Entit√©)
Pour cela il faut que le json mette les ID dans un tableau

```js
{
    "title" : "Mon Film",
    "type" : 13,
    "genres" : [105, 106]
}
```


### PUT/PATCH : modification

De quoi on a besoin ?

* d'un ID => on le r√©cup√®re de la route
* des nouvelles valeurs => on les r√©cup√®re dans le contenu

la seule diff√©rence avec la cr√©ation c'est le contexte de deserialisation o√π l'on pr√©cise que l'on veux mettre √† jour un objet existant

```php
$jsonContent = $request->getContent();
$genre = $genreRepository->find($id);
$serializerInterface->deserialize(
    // les donn√©es
    $jsonContent,
    // le type d'objet
    Genre::class,
    // le format de donn√©e
    'json',
    // ? https://symfony.com/doc/5.4/components/serializer.html#deserializing-in-an-existing-object
    // en contexte on pr√©cise que l'on veux POPULATE / PEUPLER un objet existant
    [AbstractNormalizer::OBJECT_TO_POPULATE => $genre]
);
```

#### PUT vs PATCH

[PUT](https://restfulapi.net/http-methods/#put) : modifier l'existant enti√®rement
[PATCH](https://restfulapi.net/http-methods/#patch) : modifier partiellement

il n'y a pas de consensus sur lequel utiliser.

JB propose de mettre les deux pour ne facher personne.
Mais on peux aussi documenter notre API et n'accepter qu'un des deux.

## API : DELETE

on a juste besoin d'un ID, que l'on obtient par la route, et ensuite un `remove()` depuis le repository fera l'affaire.

## API : validation des donn√©es

## API : la s√©curit√©

### analogie club med

Au club med le serveur du bar de la piscine ne sais pas si vous √™tes en all inclusive ou pas.
Il n'a pas d'outils pour le v√©rifier.

L'id√©e du club med est de mettre en palce des bracelet de couleur.
Les couleurs sont connus du serveur du bar de la piscine, grace √† √ßa il sait √† quoi vous avez le droit.

avec les bons termes :
Pour toute requetes API (bar de la piscine), il va falloir pr√©senter un token (bracelet)
Grace √† se token on va √™tre authentifier.

C'est √† l'acceuil, en arrivant, que l'on r√©cup√®re le bracelet.
C'est le seul endroit habilit√© √† le fournir.
POur vous fournir le bracelet il doit v√©rifier qui vous √™tes.

avec les bons termes :
Nous allons avoir une route qui va fournir le token.
Pour obtenir le token on va fournir un username/password

On va utiliser [lexikJWT](https://github.com/lexik/LexikJWTAuthenticationBundle) pour √ßa.

#### installation de Lexik

on suit la [doc](https://github.com/lexik/LexikJWTAuthenticationBundle/blob/2.x/Resources/doc/index.rst#installation)

```bash
composer require "lexik/jwt-authentication-bundle"
```

A faire √† la premi√®re installation : g√©n√©rer les cl√©s SSL

```bash
bin/console lexik:jwt:generate-keypair
```

cela cr√©er deux fichiers dans le dossier `config/jwt` qui sont ignor√© au niveau git.
Donc si on clone le projet, il faut regenerer les cl√©s
Si on d√©ploie en prod, il faut regenerer les cl√©s

la config dans le fichier `.env` est d√©j√† faites en auto

```yaml
# config/packages/lexik_jwt_authentication.yaml
lexik_jwt_authentication:
    secret_key: '%env(resolve:JWT_SECRET_KEY)%' # required for token creation
    public_key: '%env(resolve:JWT_PUBLIC_KEY)%' # required for token verification
    pass_phrase: '%env(JWT_PASSPHRASE)%' # required for token creation
    token_ttl: 64800 # in seconds, default is 3600
```

```yaml
#security.yaml
    firewalls:
        login:
            pattern: ^/api/login
            stateless: true
            json_login:
                check_path: /api/login_check
                success_handler: lexik_jwt_authentication.handler.authentication_success
                failure_handler: lexik_jwt_authentication.handler.authentication_failure

        api:
            pattern:   ^/api
            stateless: true
            jwt: ~


    access_control:
        - { path: ^/api/login, roles: PUBLIC_ACCESS }
```

```yaml
# routes.yaml
api_login_check:
    path: /api/login_check
```

### Dans la vrai vie

Comment on obtiens un token ?

on lance une requete sur la route `/api/login_check`
Il faut que je fournisse mon identit√© dans le contenu de ma requete

```js
{
    "username" : "admin@admin.com",
    "password" : "admin"
}
```

le username et le mot de passe sont ceux des users que l'on a cr√©er, c'est la m√™me s√©curit√©

cela me renvoit un token

```js
{
  "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpYXQiOjE2ODQ4NDg1NDUsImV4cCI6MTY4NDkxMzM0NSwicm9sZXMiOlsiUk9MRV9BRE1JTiJdLCJ1c2VybmFtZSI6ImFkbWluQGFkbWluLmNvbSJ9.bcE6CLMF9m_ubwnRAbvMc_7WVyN3XomHE6zBS0scHwAjvVwqC00rLntwG8NEk79oXoJltuaLNEEQnzqLTBImOeeg2soDPpnxSSl09bQ1E028g5OBdmApUdqCWian_pl3BHWh_4Z_suBa7xgVxr64_Q80Qcnk9TDMdXQl3Og5Rx3DL0linMsfV9yQ7TTk5EEtbZBD3bP1IOZpFU0CSyMg6F9yynqXlk1Gpb0P_elaQMORAHZ9encVHKOC2NTW8Fx5vI3zjyfGXQQASFlcGHZ4_KAX07g-MCLpwDEhy9EAMBKn1vf2SXvWWGFZ8lc0vh9v5sB1YZMpYwphYn9DdkC89g"
}
```

maintenant pour les routes s√©curis√© il faudra que je fournisse mon token.

O√π est ce que je fournit le token ?
Dans thunderclient, le vais dans la partie `Auth` puis `Bearer` je colle mon token ici.
